Здесь описаны заметки при изучении области интереса ("Тестирование программ")

1. Теоретические основы методов тестирования программ:

    1.1. Фаззинг (англ. fuzzing)

        1.1.1 Понятие
        -  Метод тестирования программного обеспечения, 
        который заключается в автоматической генерации большого количества случайных, 
        некорректных или неожиданно сформированных входных данных для программы с целью выявления ошибок,
        сбоев или уязвимостей.

        - Основная идея фаззинга — попытаться вызвать неожиданное поведение программы, 
        например, сбои, утечки памяти или другие баги, которые могут привести к уязвимостям.
        Этот метод часто используется для тестирования безопасности,
        так как он помогает находить баги, которые сложно обнаружить традиционным тестированием.

        1.1.2 Принципы работы:

        - Генерация входных данных: Фаззер создает входные данные,
        которые могут быть случайными,
        мутацией существующих данных или сконструированными по определенным правилам.

        - Исполнение программы: Эти данные передаются программе или её компоненту (например, функции или API).

        - Мониторинг поведения: Анализируется, как программа обрабатывает входные данные.
        Отслеживаются сбои, утечки памяти, неожиданные исключения, зависания и прочие аномалии.

        - Сбор результатов: Логируются ошибки или подозрительное поведение для последующего анализа разработчиками.

        1.1.3 Классификация:

        - Мутационный: Используются реальные входные данные, которые изменяются случайным образом.
        Пример: взять корректный файл JPEG и вносить в него случайные изменения.

        - Слепой (Black-box fuzzing): Входные данные генерируются без информации о внутреннем устройстве программы.
        Пример: простая генерация случайных строк для передачи в программу.

        - Фаззинг с использованием модели (White-box fuzzing):Учитываются особенности программы, например, её код или структура.
        Пример: тестирование на основе анализа путей выполнения (coverage-guided fuzzing).

        *** Идея ***: Вероятно, это нам и нужно, стоит присмотреться. Стоит попробовать сделать умный фаззинг на основе генеративной
        языковой модели. Можно обрабатывать сам код, какое-то покрытие тестами
        (с имеющимися и отсутствующими, как при .gcov имеются ####), структуру кода, получая AST-tree (Abstract Syntax Tree).

        - Фаззинг с подкреплением (из статьи): лежат алгоритмы адаптации процесса изменения потока внешних данных
        на основе информации, полученной от анализируемой программы.

    1.2 Динамическое символьное исполнение

        1.2.1 Теоретические основы
        
        "В основе предложенного метода лежит представление программы в виде операций над символьными переменными,
        соответствующим данным, обрабатываемых программой. Набор операций и условных переходов
        на пути исполнения программы формирует условие пути, которое накладывает ограничения 
        на значения символьных переменных и, следовательно, набор внешних данных. Также вводится понятие дерева 
        символьного исполнения, которое характеризует пути исполнения программы. Каждому узлу дерева ставится в 
        соответствие исполняющаяся операция, а каждому переходу к следующей операции ставится в соответствие направленная дуга.
        Каждой операций ветвления ставится две дуги: одна соответствует переходу исполнения при вычислении условия в «истину», 
        другая – переходу исполнения при вычислении условия в «ложь»".

        1.2.2 Принципы

        1. Для каждого листового узла дерева и, соответственно, завершённого пути исполнения программы 
        существует конкретный несимвольный набор внешних данных программы, который, будучи поданным на вход 
        программе при её реальном (несимвольном) исполнении, приведёт к исполнению по тому же пути (исполнению той 
        же последовательности инструкций).
        2. Условия пути для двух разных листовых узлов дерева различны. Если два пути из одного корня ведут 
        к двум различным листовым узлам, то это означает, что на пути была операция ветвления и одной ветке 
        соответствует вычисление условия ветвления в значение «истина», а другой – в значение «ложь».

        1.2.3 Как реализуется

        - Формирование ограничений (constraints):
        По мере выполнения программы на основе условий ветвлений (например, if (x > 10)) формируются ограничения для этих переменных.
        В предыдущем примере создается ограничение x > 10, если программа пошла в ветку true.

        - Решение ограничений:
        Ограничения передаются в решатель (solver), например, Z3 или CVC4, который генерирует конкретные значения входных данных,
        удовлетворяющих этим условиям. Это позволяет находить тестовые примеры для каждого пути выполнения программы.
        
        - Исполнение программы: Программа запускается с этими конкретными значениями, чтобы проверить 
        корректность её работы или воспроизвести ошибку.

        1.2.4 Concolic Execution

        - Конкретно-символьное исполнение. Термин concolic — это комбинация слов concrete (конкретное) и symbolic (символьное).
        В данном подходе программа одновременно исполняется с реальными данными и символьными переменными. Конкретное исполнение 
        используется для того, чтобы точно исполнять код программы (включая взаимодействие с внешними компонентами). Символьное 
        исполнение добавляет абстракцию и возможность анализа всех возможных ветвей программы. Это совего рода реалистичный подход,
        так как он позволяет избежать проблем с символами (например,  в случае нестандартных библиотек или сложной интерпретируемости)

        *** Итог ***: Пока у меня нет мыслей, как сюда приплести ML... но да ладно
    
        1.2.5 Недостатки:

        - Всё это дело не может в библиотечные функции (заменяет исполнением этих блоков или псевдослучайным - это может 
        повлиять на сценарий выполнения программы - назвали дивергенцией).

        - Проблемы с поддержкой анализа кода на разных языках прграммирования.

        - Не масштабируются на реальные здоровые программы.

    1.3 Статический анализ исходного кода программ

        1.3.1 Понятие
        
        - Метод исследования программного обеспечения, при котором код анализируется без его выполнения. 
        Цель — обнаружение потенциальных ошибок, уязвимостей, нарушений стандартов кодирования и других проблем на этапе разработки. 
        Этот подход применяется для повышения качества кода, обеспечения безопасности и соответствия определённым стандартам.

        1.3.2 Принципы

        - Анализ синтаксиса:
        Проверяется соответствие кода синтаксическим правилам языка. Например, анализатор выявляет некорректное 
        использование ключевых слов, незакрытые скобки или пропущенные точки с запятой.  

        - Проверяется смысл выполнения программы: корректность типов данных, неправильные преобразования типов, 
        неиспользуемые переменные.

        - Проверка стиля: Оценивается соответствие стандартам кодирования

        - Поиск дефектов и уязвимостей: Выявление потенциальных багов, таких как утечки памяти, 
        неопределённые поведения, неинициализированные переменные, а также критические уязвимости, например, SQL-инъекции.

2. Особенности методов

    1.1 Фаззинг (стр. 39-41):

    - В +: 
    
        * При анонсе проекта Springfield компании Microsoft [112] Элиссон Линн приводит утверждение ведущего исследователя 
        Microsoft Research Париса Годефруа (Patrice Godefroid), что более трети всех ошибок, обнаруженных в процессе всего цикла 
        тестирования операционной системы Windows 7, было найдено инструментом с элементами фаззинг-тестирования SAGE. 
        С другой стороны, разработчик инструмента AFL Михал Залевски оценивает количество уязвимостей удалённого исполнения кода, 
        найденных методами достаточно простого фаззинга, в примерно 70% от всего количества найденных уязвимостей за несколько лет 
        до 2015 года.

    - В -: 

      * Прежде всего, это случайный характер обнаружения ошибок и уязвимостей методами фаззинга. Даже применение фаззинга с 
        обратной связью, при котором собирается информация о прохождении исполнения через определённые базовые блоки в 
        программе (покрытие по базовым блокам) или по определенным путям (покрытие по путям), не гарантирует целенаправленного 
        обнаружения ошибок и уязвимостей.
      
      * Информация о покрытии программы учитывается в алгоритмах генерации или мутации внешних данных косвенно, 
      то есть не позволяет целенаправленно изменить поток внешних данных таким образом, чтобы гарантированно расширить 
      покрытие или найти ошибку в программе.

      * Третья проблема методов фаззинга – это прохождение потока исполнения через функции проверки внешних 
      данных на корректность. Такие методы, как сравнение с константным значением и вычисление контрольных сумм 
      в потоке внешних данных, нередко проводят исполнение программы по пути обработки ошибочных внешних данных и не 
      позволяют провести исполнение программы по путям основного алгоритма решения задачи.

    1.2 Динамическое символьное исполнение (стр. 41-42)

    - В -:

        * Во-первых, это проблема взрывного роста количества путей (англ. path explosion problem – проблема взрыва путей), 
        которые необходимо пройти в процессе проведения анализа.

        * Во-вторых, высокая сложность или невозможность применения динамического символьного исполнения для анализа с 
        достаточной точностью и за разумное время специфических функций с интенсивными математическими вычислениями, 
        адресной арифметикой, а также библиотечных функций и функций операционной системы, поведение которых приходится 
        эмулировать при неполносистемном анализе.

    - В +:

        * Тем не менее метод динамического символьного исполнения позволяет целенаправленно генерировать 
        внешние данные для направления анализа в интересующие части программы и для обнаружения дефектов в программах.

    1.3 Статический анализ исходного кода (стр. 36-39)

    - Метрики качества:

        * Полнота анализа (англ. recall), показывающая отношение количества найденных ошибок 
        к полному количеству ошибок в программе;

        * Точность анализа (англ. precision) – показывающая отношение количества истинных 
        предупреждений об ошибках к количеству ложных предупреждений об ошибках найденных инструментом;

        * Производительность (англ. performance) – количество вычислительных ресурсов, 
        требующихся для получения результата.

        В результате все инструменты статического анализа исходного кода программ создаются 
        в условиях компромисса между точностью, полнотой, производительностью и учётом требования 
        масштабируемости анализа.

    - Причины компромисса:

        *  Ограничение количества исследуемых путей. Если в программе n условных переходов, 
        то количество путей для анализа в пределе равно 2^n.

        * Если абстрактный домен слишком детализированный (например, для x мы рассматриваем не просто x = 0 и x > 0, 
        а каждое значение от 0 до 255), анализ становится очень медленным. Поэтому важно находить баланс: 
        домен должен быть достаточно простым, чтобы анализ работал быстро, но не настолько упрощённым, чтобы терялись 
        важные детали.

        * Работа с недоступным исходным текстом
        Если анализируемая программа использует сторонние библиотеки и их исходный текст недоступен, 
        то в случае вызова функций из таких библиотек наиболее популярным решением является предположение, 
        что функция ничего не делает и возвращает неизвестное значение. Несмотря на то, что функция может разыменовывать 
        параметры, менять значения глобальных переменных или прерывать исполнение программы. Как правило, в данном случае 
        существует возможность проанализировать исполняемый код библиотечных функций, что добавляет требование анализа объектного 
        кода, либо аннотировать вручную функции наиболее популярных библиотек.

3. Комбинирование методов (стр. 42-47)

    - Первая группа методов про "Guided Fuzzing": если фаззинг не покрывает какое-то ветвление, 
    то запускаем динамическое символьное исполнение и так, одно цепляется за другое по сути.

    - Вторая группа про комбинацию статического и динамического исполнения.

    - Исходя из обзора методов анализа программ, 
    наиболее перспективным направлением развития методов обнаружения ошибок в программах 
    представляется направление совмещения различных методов анализа программ с целью повышения точности результата и 
    производительности инструментов анализа программ.

4. Методы анализа программ:

    4.1 Статический анализ кода (стр. 47)

        4.1.1 Понятие

        - Методы статического анализа программ характеризуются тем, что проводят анализ без запуска программы на исполнение. 
        Современные инструменты статического анализа программ проводят анализ модели программы, полученной из исходного или 
        исполняемого кода программы.

    4.2 Анализ абстрактного синатксического дерева (Abstract Syntax Tree - AST) - стр. 47 - 49

        4.2.1 Понятие

        - Представляет собой структуру данных, в которой каждый внутренний узел дерева соответствует оператору, 
        а его дочерние узлы представляют операнды этого оператора. Фактически данная структура описывает структуру 
        исходного кода программы.

        - При помощи анализа абстрактного синтаксического дерева возможно построение анализаторов, 
        проверяющих не только такие достаточно простые правила кодирования, как проверка правил именования 
        переменных (например, на соответствие венгерской нотации) или отступов в исходном коде программ, но и ошибок, 
        влияющих на логику исполнения программы.

        - Предупреждения об ошибках, найденных при помощи модели программы в виде абстрактного синтаксического дерева, 
        как правило, представляются одной точкой в программе, указывающей на конструкцию языка программирования, 
        которая содержит ошибку.

        - Пример кода:

            ```python
            import ast
            import astpretty

            code = "a = b + c * 2"
            tree = ast.parse(code)
            astpretty.pprint(tree)
            ```
        - Пример дерева:

            Module(
                body=[
                    Assign(
                        targets=[Name(id='a', ctx=Store())],
                        value=BinOp(
                            left=Name(id='b', ctx=Load()),
                            op=Add(),
                            right=BinOp(
                                left=Name(id='c', ctx=Load()),
                                op=Mult(),
                                right=Constant(value=2),
                            ),
                        ),
                    ),
                ],
            )

        *** Идея ***: Есть смысл представлять код в виде AST для его дальнейшей токенизации и подачи в языковую модель
    
    4.3 Анализ потока программы 

        4.3.1 Понятие графа потока команды:

        - Граф потока программы представляет собой структуру, в которой узлами являются базовые блоки,
        а рёбра указывают порядок следования базовых блоков. Базовый блок – это последовательность команд, 
        имеющая одну точку входа и одну точку выхода. Анализ потока программы позволяет вычислять свойства потока 
        данных программы с учётом потока управления, что позволяет обнаруживать наиболее интересные ошибки в программе, 
        связанные с последовательностью операций над данными программы.

        4.3.2 Как выглядит граф:

        - Одной из возможных реализаций анализа потока программы является представление потока операций программы 
        в виде промежуточного представления на основе графа потока управления (англ. control-flow graph) программы, 
        в котором базовые блоки состоят из операций представленных в трехадресном коде: операция представляется в 
        виде четверок <op, arg1, arg2, res>, где op – операция, arg1 – первый аргумент операции, 
        agr2 – второй аргумент операции, res – результат операции.

        4.3.3 Пример графового потока программы (CFG - Control Flow Graph).

        from pyflowchart import Flowchart

            # Исходный код
            code = """
            def example(x):
                if x > 0:
                    print("Positive")
                else:
                    print("Non-positive")
                print("Done")
            """

            # Генерация блок-схемы
            fc = Flowchart.from_code(code)
            print(fc.flowchart())  # Вывод блок-схемы в формате flowchart.js

        4.3.2 Вывод в формате .js

            st3=>start: start example
            io5=>inputoutput: input: x
            cond9=>condition: if (x > 0)
            sub13=>subroutine: print('Positive')
            sub20=>subroutine: print('Done')
            e22=>end: end example
            sub17=>subroutine: print('Non-positive')

            st3->io5
            io5->cond9
            cond9(yes)->sub13
            sub13->sub20
            sub20->e22
            cond9(no)->sub17
            sub17->sub20
        
         *** Идея ***: Есть смысл представлять код в виде графа для его дальнейшей токенизации и подачи в языковую модель

    4.4 Анализ, чувствительный к потоку, с консервативным подходом при принятии решений
















    

    









    